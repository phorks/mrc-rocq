From Stdlib Require Import Strings.String.
From Stdlib Require Import Arith.PeanoNat. Import Nat.
From Stdlib Require Import Lia.
From Stdlib Require Import Lists.List. Import ListNotations.
From MRC Require Import Options.
From MRC Require Import Tactics.
From MRC Require Import Model.
From MRC Require Import Stdppp.
From MRC Require Import PredCalc PredCalcSubst PredCalcEquiv.
From stdpp Require Import gmap fin_maps.

Lemma fequiv_subst_and_diag A x :
  <! A[x \ x] !> ≡ A ∧ ∀ M σ t v b, teval M σ t v → feval M (<[x:=v]> σ) A b ↔ feval M σ (A[x \ t]) b.
Proof with auto.
  generalize dependent x. induction A; intros.
  - unfold subst_formula. simpl. rewrite subst_sf_diag... split...
    split; inversion 1; subst.
    + constructor. apply (sfeval_subst H)...
    + constructor. apply (sfeval_subst H)...
  - split.
    + rewrite simpl_subst_not. destruct (IHA x) as [-> _]...
    + intros. rewrite simpl_subst_not. split; inversion 1; subst.
      * constructor. apply IHA with (x:=x) (b:=b0) in H. apply H...
      * constructor. apply IHA with (x:=x) (b:=b0) in H. apply H...
  - split.
    + rewrite simpl_subst_and. destruct (IHA1 x) as [-> _]. destruct (IHA2 x) as [-> _]...
    + intros. rewrite simpl_subst_and. split; inversion 1; subst.
      * apply IHA1 with (x:=x) (b:=b1) in H as ?.
        apply IHA2 with (x:=x) (b:=b2) in H. constructor.
        -- apply H1...
        -- apply H...
      * apply IHA1 with (x:=x) (b:=b1) in H as ?.
        apply IHA2 with (x:=x) (b:=b2) in H. constructor.
        -- apply H1...
        -- apply H...
  - split.
    + rewrite simpl_subst_or. destruct (IHA1 x) as [-> _]. destruct (IHA2 x) as [-> _]...
    + intros. rewrite simpl_subst_or. split; inversion 1; subst.
      * apply IHA1 with (x:=x) (b:=b1) in H as ?.
        apply IHA2 with (x:=x) (b:=b2) in H. constructor.
        -- apply H1...
        -- apply H...
      * apply IHA1 with (x:=x) (b:=b1) in H as ?.
        apply IHA2 with (x:=x) (b:=b2) in H. constructor.
        -- apply H1...
        -- apply H...
  - split.
    { rename x into y. rename x0 into x. destruct (quant_subst_skip_cond y A x).
      - rewrite simpl_subst_exists_skip...
      - rewrite simpl_subst_exists_propagate...
        generalize_fresh_var y A x x as y'.
        intros M σ b. apply feval_exists_equiv. intros. destruct H4.
          + subst. pose proof (H':=H). forward (H' (A[y'\y'])) by auto. destruct (H' x) as [? _].
            rewrite H3. clear H'. clear H3.
            forward (H (A)) by auto. destruct (H y') as [? _].
            rewrite H3...
          + pose proof (H':=H). forward (H' (A[y\y'])) by auto. destruct (H' x) as [? _].
            rewrite H4. clear H4 H'. forward (H A) by auto. destruct (H y) as [_ ?].
            rewrite <- H4 with (v:=v).
            2: { constructor. apply lookup_insert. }
            destruct (decide (y = y')).
            * subst. rewrite (insert_insert σ)...
            * rewrite (insert_commute σ)... apply feval_delete_state_var_head... }
    intros. rename H0 into Ht. destruct (decide (x = x0)).
      + subst. rewrite simpl_subst_exists_skip... apply feval_exists_equiv.
        intros. rewrite (insert_insert σ)...
      + destruct (decide (x0 ∈ formula_fvars A)).
        2: { rewrite simpl_subst_exists_skip... rewrite feval_delete_state_var_head... simpl.
             destruct (value_ty_choice); set_solver. }
        rewrite simpl_subst_exists_propagate... generalize_fresh_var x A x0 t0 as x'.
        apply feval_exists_equiv.
        intros. destruct H2.
           * subst.
              pose proof H as H'. forward (H' (A [x' \ x'])) by auto. destruct (H' x0) as [_ ?].
              rewrite <- H1 with (v:=v)...
              2:{ apply teval_delete_state_var_head... }
              clear H3 H'.
              forward (H A)... destruct (H x') as [? _].  rewrite H2.
              rewrite (insert_commute σ)...
           * pose proof H as H'. forward (H' (A [x \ x'])) by auto. destruct (H' x0) as [_ ?].
              rewrite <- H2 with (v:=v)...
              2:{ apply teval_delete_state_var_head... }
              rewrite (insert_commute σ x0 x')...
              clear H0 H'.
              forward (H A)... destruct (H x) as [_ ?]. rewrite <- H0 with (v:=v0).
              2:{ apply TEval_Var. apply lookup_insert_Some. left... }
              rewrite (@feval_delete_state_var x' _ (<[x:=v0]> (<[x':=v0]> (<[x0:=v]> σ))))...
              rewrite (@feval_delete_state_var x' _ (<[x:=v0]> (<[x0:=v]> σ)))...
              clear H0 H Ht. f_equiv.
              destruct (decide (x = x')).
              -- subst. rewrite (insert_insert (<[x0:=v]> σ))...
              -- rewrite (insert_commute (<[x0:=v]> σ))...
                 rewrite (delete_insert_delete (<[x:=v0]> (<[x0:=v]> σ)))...
Qed.

Lemma feval_subst {M} σ A x t b v :
  teval M σ t v →
  feval M (<[x:=v]> σ) A b ↔ feval M σ (A[x \ t]) b.
Proof. apply fequiv_subst_and_diag. Qed.

Lemma fequiv_subst_diag A x :
  <! A[x \ x] !> ≡ A.
Proof with auto. apply fequiv_subst_and_diag. Qed.

Instance subst_proper : Proper ((≡@{formula}) ==> (=) ==> (=) ==> (≡@{formula})) subst_formula.
Proof with auto.
  intros A B H x ? <- t ? <- M σ b; split; intros.
  - apply feval_wf in H0 as ?.
    destruct (decide (x ∈ formula_fvars A)); destruct (decide (x ∈ formula_fvars B)).
    + apply formula_wf_subst_term_wf in H1... apply term_wf_teval in H1 as [v Hv].
      rewrite <- feval_subst with (v:=v)... apply H. rewrite feval_subst with (t:=t)...
    + apply formula_wf_subst_term_wf in H1... apply term_wf_teval in H1 as [v Hv].
      rewrite <- feval_subst with (v:=v)... apply H. rewrite feval_subst with (t:=t)...
    + exfalso. rewrite fequiv_subst_non_free in H0...
      rewrite feval_delete_state_var with (x:=x) in H0...
      apply H in H0. apply feval_wf in H0 as ?. apply formula_wf_state_covers in H2.
      set_solver.
    + rewrite fequiv_subst_non_free in H0... rewrite fequiv_subst_non_free... apply H...
  - apply feval_wf in H0 as ?.
    destruct (decide (x ∈ formula_fvars A)); destruct (decide (x ∈ formula_fvars B)).
    + apply formula_wf_subst_term_wf in H1... apply term_wf_teval in H1 as [v Hv].
      rewrite <- feval_subst with (v:=v)... apply H. rewrite feval_subst with (t:=t)...
    + exfalso. rewrite fequiv_subst_non_free in H0...
      rewrite feval_delete_state_var with (x:=x) in H0...
      apply H in H0. apply feval_wf in H0 as ?. apply formula_wf_state_covers in H2.
      set_solver.
    + apply formula_wf_subst_term_wf in H1... apply term_wf_teval in H1 as [v Hv].
      rewrite <- feval_subst with (v:=v)... apply H. rewrite feval_subst with (t:=t)...
    + rewrite fequiv_subst_non_free in H0... rewrite fequiv_subst_non_free... apply H...
Qed.

Lemma fequiv_exists_alpha_equiv x x' τ A :
  x' ∉ formula_fvars A →
  <! exists x : τ, A !> ≡ <! exists x' : τ, A[x \ x'] !>.
Proof with auto.
  intros Hfree M σ b.
  apply feval_exists_equiv.
  intros. rewrite <- feval_subst with (v:=v).
  2: { constructor. apply lookup_insert_Some. left... }
  destruct (decide (x = x')).
  + subst. rewrite (insert_insert σ)...
  + rewrite (insert_commute σ)...
    rewrite (feval_delete_state_var_head x')...
Qed.

Lemma fequiv_forall_alpha_equiv x x' τ A :
    x' ∉ formula_fvars A →
    <! forall x : τ, A !> ≡ <! forall x' : τ, A[x \ x'] !>.
Proof with auto.
  intros. unfold FForall. rewrite fequiv_exists_alpha_equiv with (x':=x')...
  rewrite simpl_subst_not...
Qed.

Lemma fequiv_exists_non_free_binder x τ A :
  x ∉ formula_fvars A →
  ((∃ v, v ∈ τ) ∧ <! exists x : τ, A !> ≡ A) ∨
    ((value_ty_is_empty τ) ∧ <! exists x : τ, A !> ≡ <! false !>).
Proof with auto.
  intros H. destruct (value_ty_choice τ).
  - left. destruct s as [v Hv]. split; [eauto |].
    intros M σ b. split; intros.
    + inversion H0; subst.
      * destruct H5 as [v' [_ ?]]. apply feval_delete_state_var_head in H1...
      * apply H5 in Hv. apply feval_delete_state_var_head in Hv...
    + destruct b.
      * apply FEval_Exists_True. exists v. split... apply feval_delete_state_var_head...
      * apply FEval_Exists_False. intros. apply feval_delete_state_var_head...
  - right. split... split; intros.
    + inversion H0; subst.
      * destruct H5 as [? [contra _]]. apply n in contra as [].
      * constructor. constructor.
    + inversion H0; subst. inversion H2; subst. constructor. intros. apply n in H1 as [].
Qed.

Lemma fequiv_subst_trans : ∀ A (x1 x2 x3 : variable),
    x2 ∉ formula_fvars A →
    <! A[x1 \ x2][x2 \ x3] !> ≡ <! A[x1 \ x3] !>.
Proof with auto.
  intros.
  destruct (decide (x1 ∈ formula_fvars A)).
  2:{ rewrite fequiv_subst_non_free with (x:=x1)... rewrite fequiv_subst_non_free...
      rewrite fequiv_subst_non_free... }
  destruct (decide (x1 = x2)).
  1:{ subst. rewrite fequiv_subst_diag... }
  destruct (decide (x2 = x3)).
  1:{ subst. rewrite fequiv_subst_diag... }
  split; intros.
  - apply feval_wf in H0 as H1. apply formula_wf_subst_term_wf in H1.
    2:{ rewrite fvars_subst_free... set_solver. }
    apply term_wf_teval in H1 as [v3 Hv3]. rewrite <- feval_subst with (v:=v3) in H0...
    apply feval_wf in H0 as H1. apply formula_wf_subst_term_wf in H1...
    apply term_wf_teval in H1 as [v2 Hv2].
    inversion Hv2; subst. apply lookup_insert_Some in H2. destruct H2 as [[? ?] | [[] _]]...
    subst v2. clear H1. rewrite <- feval_subst with (v:=v3) in H0...
    rewrite (insert_commute σ) in H0... apply feval_delete_state_var_head in H0...
    rewrite <- feval_subst with (v:=v3)...
  - apply feval_wf in H0 as H1. apply formula_wf_subst_term_wf in H1...
    apply term_wf_teval in H1 as [v3 Hv3]. rewrite <- feval_subst with (v:=v3) in H0...
    rewrite <- feval_subst with (v:=v3)... rewrite <- feval_subst with (v:=v3)...
    2:{ constructor. apply lookup_insert. }
    rewrite (insert_commute σ)... rewrite feval_delete_state_var_head...
Qed.

Lemma fequiv_subst_commute : ∀ A x1 t1 x2 t2,
    x1 ≠ x2 →
    x1 ∉ term_fvars t2 →
    x2 ∉ term_fvars t1 →
    <! A[x1 \ t1][x2 \ t2] !> ≡ <! A[x2 \ t2][x1 \ t1] !>.
Proof with auto.
  intros. split; intros.
  - destruct (decide (x1 ∈ formula_fvars A)); destruct (decide (x2 ∈ formula_fvars A)).
    + apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3.
      2:{ rewrite fvars_subst_free... apply elem_of_union. left. apply elem_of_difference.
          rewrite not_elem_of_singleton. split... }
      apply term_wf_teval in H3 as [v2 Hv2].
      rewrite <- feval_subst with (v:=v2) in H2...
      apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3...
      apply term_wf_teval in H3 as [v1 Hv1].
      rewrite <- feval_subst with (v:=v1) in H2...
      rewrite teval_delete_state_var_head in Hv1...
      apply feval_subst with (v:=v1)... apply feval_subst with (v:=v2)...
      * apply teval_delete_state_var_head...
      * rewrite (insert_commute σ)...
    + rewrite fequiv_subst_non_free in H2.
      2:{ rewrite fvars_subst_free... apply not_elem_of_union. split...
          apply not_elem_of_difference. left... }
      apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3...
      apply term_wf_teval in H3 as [v1 Hv1].
      rewrite <- feval_subst with (v:=v1) in H2...
      apply feval_subst with (v:=v1)... rewrite fequiv_subst_non_free...
    + apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3...
      2:{ rewrite fvars_subst_non_free... }
      apply term_wf_teval in H3 as [v2 Hv2].
      rewrite <- feval_subst with (v:=v2) in H2...
      rewrite fequiv_subst_non_free in H2...
      rewrite fequiv_subst_non_free.
      2:{ rewrite fvars_subst_free...  apply not_elem_of_union. split...
          apply not_elem_of_difference. left... }
      apply feval_subst with (v:=v2)...
    + rewrite fequiv_subst_non_free in H2 by (rewrite fvars_subst_non_free; auto).
      rewrite fequiv_subst_non_free in H2...
      rewrite fequiv_subst_non_free by (rewrite fvars_subst_non_free; auto).
      rewrite fequiv_subst_non_free...
  - destruct (decide (x1 ∈ formula_fvars A)); destruct (decide (x2 ∈ formula_fvars A)).
    + apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3.
      2:{ rewrite fvars_subst_free... apply elem_of_union. left. apply elem_of_difference.
          rewrite not_elem_of_singleton. split... }
      apply term_wf_teval in H3 as [v1 Hv1].
      rewrite <- feval_subst with (v:=v1) in H2...
      apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3...
      apply term_wf_teval in H3 as [v2 Hv2].
      rewrite <- feval_subst with (v:=v2) in H2...
      rewrite teval_delete_state_var_head in Hv2...
      apply feval_subst with (v:=v2)... apply feval_subst with (v:=v1)...
      * apply teval_delete_state_var_head...
      * rewrite (insert_commute σ)...
    + apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3...
      2:{ rewrite fvars_subst_non_free... }
      apply term_wf_teval in H3 as [v1 Hv1].
      rewrite <- feval_subst with (v:=v1) in H2...
      rewrite fequiv_subst_non_free in H2...
      rewrite fequiv_subst_non_free.
      2:{ rewrite fvars_subst_free...  apply not_elem_of_union. split...
          apply not_elem_of_difference. left... }
      apply feval_subst with (v:=v1)...
    + rewrite fequiv_subst_non_free in H2.
      2:{ rewrite fvars_subst_free... apply not_elem_of_union. split...
          apply not_elem_of_difference. left... }
      apply feval_wf in H2 as H3. apply formula_wf_subst_term_wf in H3...
      apply term_wf_teval in H3 as [v2 Hv2].
      rewrite <- feval_subst with (v:=v2) in H2...
      apply feval_subst with (v:=v2)... rewrite fequiv_subst_non_free...
    + rewrite fequiv_subst_non_free in H2 by (rewrite fvars_subst_non_free; auto).
      rewrite fequiv_subst_non_free in H2...
      rewrite fequiv_subst_non_free by (rewrite fvars_subst_non_free; auto).
      rewrite fequiv_subst_non_free...
Qed.
(* Lemma fequiv_exists_subst_skip : ∀ y A x t, *)


(* Lemma subst_eq_congr : forall M σ φ x t u b, *)
(*   feval M σ <! t = u !> → *)
(*   feval M σ <! φ[x\t] !> b <→ *)
(*   feval M σ <! φ[x\u] !> b. *)
(* Proof with auto. *)

(* Lemma feval_eq_refl : forall t st, *)
(*   ~ feval M σ (F_Simple (φT_Pred "="%string [t; t])) false. *)
(* Proof with auto. *)
(*   intros t st contra. inversion contra; subst. *)
(*   inversion H0; subst. *)
(*   destruct (pctx_eq_semantics pctx) as [eq_pdef [Heqp1 Heqp2]]. *)
(*   rewrite Heqp1 in H2. inversion H2. subst pdef. *)
(*   destruct (Heqp2 st fctx) as [Heqp_refl _]. *)
(*   specialize (Heqp_refl t). *)
(*   assert (feval M σ fctx pctx <! t = t !> true). *)
(*   { apply FEval_Simple. apply SFEval_Pred with eq_pdef... *)
(*     destruct eq_pdef. *)
(*     apply Pred_Eval with n_params prel Hfnal... } *)
(*   destruct (feval_functional _ _ _ _ H contra). *)
(* Qed. *)
